esphome:
  name: crowpanel-crypto
  friendly_name: CrowPanel Crypto
  on_boot:
    priority: 800
    then:
      # Publish restored alert thresholds to HA numbers
      - lambda: |-
          id(num_alert_btc).publish_state(id(alert_price_btc));
          id(num_alert_eth).publish_state(id(alert_price_eth));
          id(num_alert_sol).publish_state(id(alert_price_sol));
          id(num_alert_ada).publish_state(id(alert_price_ada));
          id(num_alert_bnb).publish_state(id(alert_price_bnb));
          // Publish restored switch states (enabled & direction)
          id(sw_alert_enabled_btc).publish_state(id(alert_enabled_btc));
          id(sw_alert_enabled_eth).publish_state(id(alert_enabled_eth));
          id(sw_alert_enabled_sol).publish_state(id(alert_enabled_sol));
          id(sw_alert_enabled_ada).publish_state(id(alert_enabled_ada));
          id(sw_alert_enabled_bnb).publish_state(id(alert_enabled_bnb));
          id(sw_alert_dir_btc).publish_state(id(alert_dir_btc) >= 0);
          id(sw_alert_dir_eth).publish_state(id(alert_dir_eth) >= 0);
          id(sw_alert_dir_sol).publish_state(id(alert_dir_sol) >= 0);
          id(sw_alert_dir_ada).publish_state(id(alert_dir_ada) >= 0);
          id(sw_alert_dir_bnb).publish_state(id(alert_dir_bnb) >= 0);
          // Re-publish selects so HA UI shows the restored selections immediately
          id(sel_currency).publish_state(id(sel_currency).state);
          id(sel_row1).publish_state(id(sel_row1).state);
          id(sel_row2).publish_state(id(sel_row2).state);
          id(sel_row3).publish_state(id(sel_row3).state);
          id(sel_row4).publish_state(id(sel_row4).state);
          id(sel_row5).publish_state(id(sel_row5).state);

          // make HA sensors available immediately
          id(status_line).publish_state("Booting…");
          id(info_last_line).publish_state("Last update: —");
          id(info_fx_line).publish_state("USD->?: —");
          id(info_wifi_line).publish_state("WiFi: —");
          id(info_ip_line).publish_state("IP: —");
          id(info_uptime_line).publish_state("Uptime: —");

          // show dashes until first fetch
          id(btc_line_ha).publish_state("-");
          id(eth_line_ha).publish_state("-");
          id(sol_line_ha).publish_state("-");
          id(ada_line_ha).publish_state("-");
          id(bnb_line_ha).publish_state("-");

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

psram:
  mode: octal
  speed: 80MHz

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap: { ssid: "CrowPanel-Setup" }
  on_connect:
    then:
      - logger.log: "WiFi connected -> fetching…"
      - lvgl.label.update: { id: status, text: "WiFi OK, fetching…" }
      - script.execute: fetch_prices

captive_portal:

time:
  - platform: sntp
    id: ntp
    timezone: Europe/Stockholm
    on_time_sync:
      then:
        - logger.log: "Time synced -> fetching…"
        - lvgl.label.update: { id: status, text: "Time synced, fetching…" }
        - script.execute: fetch_prices

logger:
  level: DEBUG

api:

ota:
  - platform: esphome

# Backlight
output:
  - platform: ledc
    pin: 2
    id: bl_pwm
    frequency: 20000 Hz

light:
  - platform: monochromatic
    id: backlight
    output: bl_pwm
    restore_mode: ALWAYS_ON

# I2C for GT911 touch
i2c:
  sda: GPIO19
  scl: GPIO20
  scan: true

touchscreen:
  - platform: gt911
    id: touch
    address: 0x5D

# CrowPanel S3 RGB display
display:
  - platform: rpi_dpi_rgb
    id: main_display
    dimensions: { width: 800, height: 480 }
    color_order: RGB
    invert_colors: true
    update_interval: never
    auto_clear_enabled: false
    de_pin: 40
    hsync_pin: 39
    vsync_pin: 41
    pclk_pin: 0
    pclk_frequency: 16MHz
    pclk_inverted: true
    # 800x480 timings
    hsync_back_porch: 40
    hsync_pulse_width: 48
    hsync_front_porch: 40
    vsync_back_porch: 27
    vsync_pulse_width: 3
    vsync_front_porch: 13
    data_pins:
      red:   [45, 48, 47, 21, 14]
      green: [ 5,  6,  7, 15, 16, 4]
      blue:  [ 8,  3, 46,  9,  1]

# ====================== UI (LVGL) ======================
lvgl:
  color_depth: 16
  touchscreens: [touch]

  on_boot:
    then:
      - lvgl.widget.show: boot_blocker
      - delay: 1000ms
      - lambda: |-
          // stop any scroll behavior and reset Y
          lv_obj_clear_flag(id(root), LV_OBJ_FLAG_SCROLLABLE);
          lv_obj_clear_flag(id(page_prices), LV_OBJ_FLAG_SCROLLABLE);
          lv_obj_clear_flag(id(page_info), LV_OBJ_FLAG_SCROLLABLE);
          lv_obj_clear_flag(id(page_settings), LV_OBJ_FLAG_SCROLLABLE);
          lv_obj_clear_flag(id(nav_bar), LV_OBJ_FLAG_SCROLLABLE);
          lv_obj_scroll_to_y(id(root), 0, LV_ANIM_OFF);
          lv_obj_scroll_to_y(id(page_prices), 0, LV_ANIM_OFF);
          lv_obj_set_y(id(root), 0);
          lv_obj_set_y(id(page_prices), 0);
          lv_obj_set_y(id(nav_bar), 416);

          // Reflect saved colorize toggle
          if (lv_obj_is_valid(id(sw_colorize))) {
            if (id(colorize_pct)) lv_obj_add_state(id(sw_colorize), LV_STATE_CHECKED);
            else                  lv_obj_clear_state(id(sw_colorize), LV_STATE_CHECKED);
          }

          auto pretty = [](const std::string& s)->std::string{
            if (s=="BTC") return "Bitcoin (BTC)";
            if (s=="ETH") return "Ethereum (ETH)";
            if (s=="SOL") return "Solana (SOL)";
            if (s=="ADA") return "Cardano (ADA)";
            if (s=="BNB") return "BNB (BNB)";
            if (s=="XRP") return "XRP (XRP)";
            if (s=="DOGE") return "Dogecoin (DOGE)";
            if (s=="AVAX") return "Avalanche (AVAX)";
            if (s=="DOT") return "Polkadot (DOT)";
            if (s=="LINK") return "Chainlink (LINK)";
            if (s=="MATIC") return "Polygon (MATIC)";
            if (s=="POL") return "Polygon (POL)";
            if (s=="TON") return "Toncoin (TON)";
            if (s=="TRX") return "TRON (TRX)";
            if (s=="NEAR") return "NEAR (NEAR)";
            if (s=="ATOM") return "Cosmos (ATOM)";
            if (s=="APT") return "Aptos (APT)";
            if (s=="OP") return "Optimism (OP)";
            if (s=="ARB") return "Arbitrum (ARB)";
            if (s=="SUI") return "Sui (SUI)";
            return s + " (" + s + ")";
          };

          // Reflect currency select on Settings label and Prices title
          {
            std::string cur = id(sel_currency).state; if (cur.empty()) cur = "DKK";
            if (lv_obj_is_valid(id(lbl_currency))) lv_label_set_text(id(lbl_currency), cur.c_str());
            if (lv_obj_is_valid(id(title))) {
              char ttl[32]; snprintf(ttl, sizeof(ttl), "Crypto (%s)", cur.c_str());
              lv_label_set_text(id(title), ttl);
            }
          }

          // Set row names from coin selects
          lv_label_set_text(id(btc_name), pretty(id(sel_row1).state).c_str());
          lv_label_set_text(id(eth_name), pretty(id(sel_row2).state).c_str());
          lv_label_set_text(id(sol_name), pretty(id(sel_row3).state).c_str());
          lv_label_set_text(id(ada_name), pretty(id(sel_row4).state).c_str());
          lv_label_set_text(id(bnb_name), pretty(id(sel_row5).state).c_str());
      - lvgl.widget.hide: boot_blocker

  widgets:
    - obj:
        id: root
        x: 0
        y: 0
        width: 800
        height: 480
        bg_color: 0x000000
        bg_opa: "100%"
        radius: 0
        pad_all: 0
        scrollbar_mode: "OFF"
        scroll_chain: "OFF"
        scrollable: false
        widgets:

          # ---------- Page: Prices ----------
          - obj:
              id: page_prices
              x: 0
              y: 0
              width: 800
              height: 416
              bg_opa: "0%"
              scrollbar_mode: "OFF"
              scroll_chain: "OFF"
              scrollable: false
              widgets:
                - label:
                    id: title
                    x: 20
                    y: 10
                    text: "Crypto (DKK)"
                    text_color: 0xFFFFFF
                    text_font: "montserrat_30"

                # Left column: names (now driven by selects)
                - label: { id: btc_name, x: 20,  y: 60,  text: "Bitcoin (BTC)",  text_color: 0xA3B8D1, text_font: "montserrat_22" }
                - label: { id: eth_name, x: 20,  y: 120, text: "Ethereum (ETH)", text_color: 0xA3B8D1, text_font: "montserrat_22" }
                - label: { id: sol_name, x: 20,  y: 180, text: "Solana (SOL)",   text_color: 0xA3B8D1, text_font: "montserrat_22" }
                - label: { id: ada_name, x: 20,  y: 240, text: "Cardano (ADA)",  text_color: 0xA3B8D1, text_font: "montserrat_22" }
                - label: { id: bnb_name, x: 20,  y: 300, text: "BNB (BNB)",      text_color: 0xA3B8D1, text_font: "montserrat_22" }

                # Right column: values
                - label: { id: btc_val, x: 330, y: 60,  text: "-", text_color: 0xE2E8F0, text_font: "montserrat_28", recolor: true }
                - label: { id: eth_val, x: 330, y: 120, text: "-", text_color: 0xE2E8F0, text_font: "montserrat_28", recolor: true }
                - label: { id: sol_val, x: 330, y: 180, text: "-", text_color: 0xE2E8F0, text_font: "montserrat_28", recolor: true }
                - label: { id: ada_val, x: 330, y: 240, text: "-", text_color: 0xE2E8F0, text_font: "montserrat_28", recolor: true }
                - label: { id: bnb_val, x: 330, y: 300, text: "-", text_color: 0xE2E8F0, text_font: "montserrat_28", recolor: true }

                # Tap areas
                - button: { id: btn_row_btc, x: 0, y:  48, width: 800, height: 48, radius: 0, bg_opa: "0%" }
                - button: { id: btn_row_eth, x: 0, y: 108, width: 800, height: 48, radius: 0, bg_opa: "0%" }
                - button: { id: btn_row_sol, x: 0, y: 168, width: 800, height: 48, radius: 0, bg_opa: "0%" }
                - button: { id: btn_row_ada, x: 0, y: 228, width: 800, height: 48, radius: 0, bg_opa: "0%" }
                - button: { id: btn_row_bnb, x: 0, y: 288, width: 800, height: 48, radius: 0, bg_opa: "0%" }

                # Status (top-right)
                - label:
                    id: status
                    align: "TOP_RIGHT"
                    x: -20
                    y: 10
                    text: "Booting…"
                    text_color: 0x94A3B8
                    text_font: "montserrat_20"

                # --- Alert bar (hidden by default; flashes when an alert trips) ---
                - obj:
                    id: alert_bar
                    x: 20
                    y: 356
                    width: 760
                    height: 44
                    radius: 6
                    bg_color: 0x7C2D12
                    bg_opa: "100%"
                    hidden: true
                    scrollable: false
                    widgets:
                      - label:
                          id: alert_text
                          align: "CENTER"
                          text: ""
                          text_color: 0xFFFFFF
                          text_font: "montserrat_22"
                      # Transparent full-width button to allow dismiss on tap
                      - button:
                          id: btn_alert_dismiss
                          x: 0
                          y: 0
                          width: 760
                          height: 44
                          radius: 6
                          bg_opa: "0%"

          # ---------- Page: Info ----------
          - obj:
              id: page_info
              x: 0
              y: 0
              width: 800
              height: 416
              hidden: true
              bg_opa: "0%"
              scrollbar_mode: "OFF"
              scroll_chain: "OFF"
              scrollable: false
              widgets:
                - label: { x: 20,  y: 10,  text: "System & Data", text_color: 0xFFFFFF, text_font: "montserrat_26" }

                - label: { id: info_last,   x: 20,  y: 60,  text: "Last update: —",  text_color: 0xE2E8F0, text_font: "montserrat_20" }
                - label: { id: info_fx,     x: 20,  y: 100, text: "USD->DKK: —",    text_color: 0xE2E8F0, text_font: "montserrat_20" }
                - label: { id: info_wifi,   x: 20,  y: 140, text: "WiFi: —",        text_color: 0xE2E8F0, text_font: "montserrat_20" }
                - label: { id: info_ip,     x: 20,  y: 180, text: "IP: —",          text_color: 0xE2E8F0, text_font: "montserrat_20" }
                - label: { id: info_uptime, x: 20,  y: 220, text: "Uptime: —",      text_color: 0xE2E8F0, text_font: "montserrat_20" }

                - label:
                    x: 20
                    y: 260
                    text: "Sources: Frankfurter (FX), Binance (prices)"
                    text_color: 0x94A3B8
                    text_font: "montserrat_18"

          # ---------- Page: Settings ----------
          - obj:
              id: page_settings
              x: 0
              y: 0
              width: 800
              height: 416
              hidden: true
              bg_opa: "0%"
              scrollbar_mode: "OFF"
              scroll_chain: "OFF"
              scrollable: false
              widgets:
                - label:
                    x: 220
                    y: 160
                    text: "Colorize % change"
                    text_color: 0xE2E8F0
                    text_font: "montserrat_22"
                - switch:
                    id: sw_colorize
                    x: 560
                    y: 156
                    width: 80
                    height: 32

                - label:
                    x: 220
                    y: 210
                    text: "Currency"
                    text_color: 0xE2E8F0
                    text_font: "montserrat_22"

                - button:
                    id: btn_cur_left
                    x: 480
                    y: 204
                    width: 40
                    height: 40
                    radius: 6
                    widgets:
                      - label: { align: "CENTER", text: "◀", text_font: "montserrat_22" }

                - label:
                    id: lbl_currency
                    x: 530
                    y: 210
                    text: "DKK"
                    text_color: 0xE2E8F0
                    text_font: "montserrat_22"

                - button:
                    id: btn_cur_right
                    x: 620
                    y: 204
                    width: 40
                    height: 40
                    radius: 6
                    widgets:
                      - label: { align: "CENTER", text: "▶", text_font: "montserrat_22" }

          # ---------- Coin Detail Page ----------
          - obj:
              id: page_coin
              x: 0
              y: 0
              width: 800
              height: 416
              hidden: true
              bg_opa: "0%"
              scrollbar_mode: "OFF"
              scroll_chain: "OFF"
              scrollable: false
              widgets:
                - label: { id: coin_title, x: 20, y: 10, text: "Coin", text_color: 0xFFFFFF, text_font: "montserrat_30" }
                - label: { id: coin_price_line, x: 20, y: 60, text: "-", text_color: 0xE2E8F0, text_font: "montserrat_28", recolor: true }

                - obj:
                    id: chart_frame
                    x: 20
                    y: 110
                    width: 760
                    height: 200
                    radius: 6
                    bg_color: 0x1F2937
                    bg_opa: "100%"
                    scrollable: false
                    widgets:
                      - line:
                          id: chart_line
                          x: 12
                          y: 12
                          width: 736
                          height: 176
                          points:
                            - "0, 176"
                            - "1, 175"
                          line_width: 6
                          line_color: 0x60A5FA
                          line_rounded: true

          # ---------- Bottom Nav Bar ----------
          - obj:
              id: nav_bar
              x: 0
              y: 416
              width: 800
              height: 64
              bg_color: 0x20252B
              bg_opa: "100%"
              pad_all: 8
              radius: 0
              scrollbar_mode: "OFF"
              scroll_chain: "OFF"
              scrollable: false
              widgets:
                - button:
                    id: btn_prices
                    x: 20
                    y: 8
                    width: 240
                    height: 48
                    radius: 6
                    widgets:
                      - label: { align: "CENTER", text: "Prices", text_font: "montserrat_22" }

                - button:
                    id: btn_info
                    x: 280
                    y: 8
                    width: 240
                    height: 48
                    radius: 6
                    widgets:
                      - label: { align: "CENTER", text: "Info", text_font: "montserrat_22" }

                - button:
                    id: btn_settings
                    x: 540
                    y: 8
                    width: 240
                    height: 48
                    radius: 6
                    widgets:
                      - label: { align: "CENTER", text: "Settings", text_font: "montserrat_22" }

          # ---------- Transparent boot overlay ----------
          - button:
              id: boot_blocker
              x: 0
              y: 0
              width: 800
              height: 480
              radius: 0
              bg_opa: "0%"
              hidden: true

# Text sensors (drive value labels & status)
text_sensor:
  # LVGL-only, hidden from HA
  - platform: template
    id: btc_line
    internal: true
    on_value: [lvgl.label.update: { id: btc_val, text: !lambda 'return x;' }]

  - platform: template
    id: eth_line
    internal: true
    on_value: [lvgl.label.update: { id: eth_val, text: !lambda 'return x;' }]

  - platform: template
    id: sol_line
    internal: true
    on_value: [lvgl.label.update: { id: sol_val, text: !lambda 'return x;' }]

  - platform: template
    id: ada_line
    internal: true
    on_value: [lvgl.label.update: { id: ada_val, text: !lambda 'return x;' }]

  - platform: template
    id: bnb_line
    internal: true
    on_value: [lvgl.label.update: { id: bnb_val, text: !lambda 'return x;' }]

  # HA-visible copies for device Settings
  - platform: template
    name: "Row 1 Value"
    id: btc_line_ha
    entity_category: diagnostic
    icon: mdi:currency-usd
    lambda: |-
      std::string s = id(btc_line).state;
      size_t paren = s.find("  (");              // two spaces + "(" before color/pct
      std::string left = (paren != std::string::npos) ? s.substr(0, paren) : s;
      // If you want ONLY the numeric part (no currency), uncomment the 2 lines below:
      // size_t sp = left.find(' ');
      // if (sp != std::string::npos) left = left.substr(sp + 1);
      return { left };
    update_interval: 5s

# Row 2 (HA)
  - platform: template
    name: "Row 2 Value"
    id: eth_line_ha
    entity_category: diagnostic
    icon: mdi:currency-usd
    lambda: |-
      std::string s = id(eth_line).state;
      size_t paren = s.find("  (");
      std::string left = (paren != std::string::npos) ? s.substr(0, paren) : s;
      // size_t sp = left.find(' '); if (sp != std::string::npos) left = left.substr(sp + 1);
      return { left };
    update_interval: 5s

# Row 3 (HA)
  - platform: template
    name: "Row 3 Value"
    id: sol_line_ha
    entity_category: diagnostic
    icon: mdi:currency-usd
    lambda: |-
      std::string s = id(sol_line).state;
      size_t paren = s.find("  (");
      std::string left = (paren != std::string::npos) ? s.substr(0, paren) : s;
      // size_t sp = left.find(' '); if (sp != std::string::npos) left = left.substr(sp + 1);
      return { left };
    update_interval: 5s

# Row 4 (HA)
  - platform: template
    name: "Row 4 Value"
    id: ada_line_ha
    entity_category: diagnostic
    icon: mdi:currency-usd
    lambda: |-
      std::string s = id(ada_line).state;
      size_t paren = s.find("  (");
      std::string left = (paren != std::string::npos) ? s.substr(0, paren) : s;
      // size_t sp = left.find(' '); if (sp != std::string::npos) left = left.substr(sp + 1);
      return { left };
    update_interval: 5s

# Row 5 (HA)
  - platform: template
    name: "Row 5 Value"
    id: bnb_line_ha
    entity_category: diagnostic
    icon: mdi:currency-usd
    lambda: |-
      std::string s = id(bnb_line).state;
      size_t paren = s.find("  (");
      std::string left = (paren != std::string::npos) ? s.substr(0, paren) : s;
      // size_t sp = left.find(' '); if (sp != std::string::npos) left = left.substr(sp + 1);
      return { left };
    update_interval: 5s

  # Page Info (exposed and still drive LVGL)
  - platform: template
    name: "Status"
    id: status_line
    entity_category: diagnostic
    icon: mdi:information
    on_value: [lvgl.label.update: { id: status, text: !lambda 'return x;' }]

  - platform: template
    name: "Last Update"
    id: info_last_line
    entity_category: diagnostic
    icon: mdi:clock-outline
    on_value: [lvgl.label.update: { id: info_last, text: !lambda 'return x;' }]

  - platform: template
    name: "FX Rate"
    id: info_fx_line
    entity_category: diagnostic
    icon: mdi:cash-multiple
    on_value: [lvgl.label.update: { id: info_fx, text: !lambda 'return x;' }]

  - platform: template
    name: "WiFi"
    id: info_wifi_line
    entity_category: diagnostic
    icon: mdi:wifi
    on_value: [lvgl.label.update: { id: info_wifi, text: !lambda 'return x;' }]

  - platform: template
    name: "IP Address"
    id: info_ip_line
    entity_category: diagnostic
    icon: mdi:ip
    on_value: [lvgl.label.update: { id: info_ip, text: !lambda 'return x;' }]

  - platform: template
    name: "Uptime"
    id: info_uptime_line
    entity_category: diagnostic
    icon: mdi:clock-outline
    on_value: [lvgl.label.update: { id: info_uptime, text: !lambda 'return x;' }]

  # Keep wifi_info internal; it just feeds the visible IP text sensor above
  - platform: wifi_info
    ip_address:
      id: wifi_ip
      internal: true
      on_value:
        then:
          - lambda: |-
              std::string s = "IP: " + x;
              id(info_ip_line).publish_state(s);
    ssid:
      id: wifi_ssid
      internal: true

sensor:
  - platform: wifi_signal
    id: wifi_rssi
    update_interval: 30s
    on_value:
      then:
        - lambda: |-
            char buf[96];
            snprintf(buf, sizeof(buf), "WiFi: %s  (%d dBm)",
                     id(wifi_ssid).state.c_str(), (int)x);
            id(info_wifi_line).publish_state(buf);

  - platform: uptime
    id: sys_uptime
    update_interval: 60s
    on_value:
      then:
        - lambda: |-
            uint32_t s = (uint32_t) x;
            uint32_t d = s / 86400; s %= 86400;
            uint32_t h = s / 3600;  s %= 3600;
            uint32_t m = s / 60;
            char buf[64];
            if (d) snprintf(buf, sizeof(buf), "Uptime: %ud %02u:%02u", d, h, m);
            else   snprintf(buf, sizeof(buf), "Uptime: %02u:%02u", h, m);
            id(info_uptime_line).publish_state(buf);

# Bottom nav button clicks -> page switching
binary_sensor:
  # ---- Bottom nav buttons ----
  - platform: lvgl
    id: bs_btn_prices
    widget: btn_prices
    on_click:
      then:
        - lvgl.widget.show: page_prices
        - lvgl.widget.hide: page_info
        - lvgl.widget.hide: page_settings
        - lvgl.widget.hide: page_coin

  - platform: lvgl
    id: bs_btn_info
    widget: btn_info
    on_click:
      then:
        - lvgl.widget.hide: page_prices
        - lvgl.widget.show: page_info
        - lvgl.widget.hide: page_settings
        - lvgl.widget.hide: page_coin

  - platform: lvgl
    id: bs_btn_settings
    widget: btn_settings
    on_click:
      then:
        - lvgl.widget.hide: page_prices
        - lvgl.widget.hide: page_info
        - lvgl.widget.show: page_settings
        - lvgl.widget.hide: page_coin

  # ---- Settings: Colorize % toggle ----
  - platform: lvgl
    id: bs_colorize_toggle
    widget: sw_colorize
    on_click:
      then:
        - lambda: |-
            bool on = lv_obj_has_state(id(sw_colorize), LV_STATE_CHECKED);
            id(colorize_pct) = on;
        - script.execute: fetch_prices

  # ---- Prices page: row tap targets -> Coin detail page ----
  - platform: lvgl
    id: bs_row_btc
    widget: btn_row_btc
    on_click:
      then:
        - lambda: |-
            id(current_coin) = 0;
            auto pretty = [](const std::string& s)->std::string{
              if (s=="BTC") return "Bitcoin (BTC)";
              if (s=="ETH") return "Ethereum (ETH)";
              if (s=="SOL") return "Solana (SOL)";
              if (s=="ADA") return "Cardano (ADA)";
              if (s=="BNB") return "BNB (BNB)";
              if (s=="XRP") return "XRP (XRP)";
              if (s=="DOGE") return "Dogecoin (DOGE)";
              if (s=="AVAX") return "Avalanche (AVAX)";
              if (s=="DOT") return "Polkadot (DOT)";
              if (s=="LINK") return "Chainlink (LINK)";
              if (s=="MATIC") return "Polygon (MATIC)";
              if (s=="POL") return "Polygon (POL)";
              if (s=="TON") return "Toncoin (TON)";
              if (s=="TRX") return "TRON (TRX)";
              if (s=="NEAR") return "NEAR (NEAR)";
              if (s=="ATOM") return "Cosmos (ATOM)";
              if (s=="APT") return "Aptos (APT)";
              if (s=="OP") return "Optimism (OP)";
              if (s=="ARB") return "Arbitrum (ARB)";
              if (s=="SUI") return "Sui (SUI)";
              return s + " (" + s + ")";
            };
            lv_label_set_text(id(coin_title), pretty(id(sel_row1).state).c_str());
            lv_label_set_text(id(coin_price_line), lv_label_get_text(id(btc_val)));
        - lvgl.widget.hide: page_prices
        - lvgl.widget.show: page_coin
        - script.execute: fetch_prices

  - platform: lvgl
    id: bs_row_eth
    widget: btn_row_eth
    on_click:
      then:
        - lambda: |-
            id(current_coin) = 1;
            auto pretty = [](const std::string& s)->std::string{
              if (s=="BTC") return "Bitcoin (BTC)";
              if (s=="ETH") return "Ethereum (ETH)";
              if (s=="SOL") return "Solana (SOL)";
              if (s=="ADA") return "Cardano (ADA)";
              if (s=="BNB") return "BNB (BNB)";
              if (s=="XRP") return "XRP (XRP)";
              if (s=="DOGE") return "Dogecoin (DOGE)";
              if (s=="AVAX") return "Avalanche (AVAX)";
              if (s=="DOT") return "Polkadot (DOT)";
              if (s=="LINK") return "Chainlink (LINK)";
              if (s=="MATIC") return "Polygon (MATIC)";
              if (s=="POL") return "Polygon (POL)";
              if (s=="TON") return "Toncoin (TON)";
              if (s=="TRX") return "TRON (TRX)";
              if (s=="NEAR") return "NEAR (NEAR)";
              if (s=="ATOM") return "Cosmos (ATOM)";
              if (s=="APT") return "Aptos (APT)";
              if (s=="OP") return "Optimism (OP)";
              if (s=="ARB") return "Arbitrum (ARB)";
              if (s=="SUI") return "Sui (SUI)";
              return s + " (" + s + ")";
            };
            lv_label_set_text(id(coin_title), pretty(id(sel_row2).state).c_str());
            lv_label_set_text(id(coin_price_line), lv_label_get_text(id(eth_val)));
        - lvgl.widget.hide: page_prices
        - lvgl.widget.show: page_coin
        - script.execute: fetch_prices

  - platform: lvgl
    id: bs_row_sol
    widget: btn_row_sol
    on_click:
      then:
        - lambda: |-
            id(current_coin) = 2;
            auto pretty = [](const std::string& s)->std::string{
              if (s=="SOL") return "Solana (SOL)";
              if (s=="BTC") return "Bitcoin (BTC)";
              if (s=="ETH") return "Ethereum (ETH)";
              if (s=="ADA") return "Cardano (ADA)";
              if (s=="BNB") return "BNB (BNB)";
              if (s=="XRP") return "XRP (XRP)";
              if (s=="DOGE") return "Dogecoin (DOGE)";
              if (s=="AVAX") return "Avalanche (AVAX)";
              if (s=="DOT") return "Polkadot (DOT)";
              if (s=="LINK") return "Chainlink (LINK)";
              if (s=="MATIC") return "Polygon (MATIC)";
              if (s=="POL") return "Polygon (POL)";
              if (s=="TON") return "Toncoin (TON)";
              if (s=="TRX") return "TRON (TRX)";
              if (s=="NEAR") return "NEAR (NEAR)";
              if (s=="ATOM") return "Cosmos (ATOM)";
              if (s=="APT") return "Aptos (APT)";
              if (s=="OP") return "Optimism (OP)";
              if (s=="ARB") return "Arbitrum (ARB)";
              if (s=="SUI") return "Sui (SUI)";
              return s + " (" + s + ")";
            };
            lv_label_set_text(id(coin_title), pretty(id(sel_row3).state).c_str());
            lv_label_set_text(id(coin_price_line), lv_label_get_text(id(sol_val)));
        - lvgl.widget.hide: page_prices
        - lvgl.widget.show: page_coin
        - script.execute: fetch_prices

  - platform: lvgl
    id: bs_row_ada
    widget: btn_row_ada
    on_click:
      then:
        - lambda: |-
            id(current_coin) = 3;
            auto pretty = [](const std::string& s)->std::string{
              if (s=="ADA") return "Cardano (ADA)";
              if (s=="BTC") return "Bitcoin (BTC)";
              if (s=="ETH") return "Ethereum (ETH)";
              if (s=="SOL") return "Solana (SOL)";
              if (s=="BNB") return "BNB (BNB)";
              if (s=="XRP") return "XRP (XRP)";
              if (s=="DOGE") return "Dogecoin (DOGE)";
              if (s=="AVAX") return "Avalanche (AVAX)";
              if (s=="DOT") return "Polkadot (DOT)";
              if (s=="LINK") return "Chainlink (LINK)";
              if (s=="MATIC") return "Polygon (MATIC)";
              if (s=="POL") return "Polygon (POL)";
              if (s=="TON") return "Toncoin (TON)";
              if (s=="TRX") return "TRON (TRX)";
              if (s=="NEAR") return "NEAR (NEAR)";
              if (s=="ATOM") return "Cosmos (ATOM)";
              if (s=="APT") return "Aptos (APT)";
              if (s=="OP") return "Optimism (OP)";
              if (s=="ARB") return "Arbitrum (ARB)";
              if (s=="SUI") return "Sui (SUI)";
              return s + " (" + s + ")";
            };
            lv_label_set_text(id(coin_title), pretty(id(sel_row4).state).c_str());
            lv_label_set_text(id(coin_price_line), lv_label_get_text(id(ada_val)));
        - lvgl.widget.hide: page_prices
        - lvgl.widget.show: page_coin
        - script.execute: fetch_prices

  - platform: lvgl
    id: bs_row_bnb
    widget: btn_row_bnb
    on_click:
      then:
        - lambda: |-
            id(current_coin) = 4;
            auto pretty = [](const std::string& s)->std::string{
              if (s=="BNB") return "BNB (BNB)";
              if (s=="BTC") return "Bitcoin (BTC)";
              if (s=="ETH") return "Ethereum (ETH)";
              if (s=="SOL") return "Solana (SOL)";
              if (s=="ADA") return "Cardano (ADA)";
              if (s=="XRP") return "XRP (XRP)";
              if (s=="DOGE") return "Dogecoin (DOGE)";
              if (s=="AVAX") return "Avalanche (AVAX)";
              if (s=="DOT") return "Polkadot (DOT)";
              if (s=="LINK") return "Chainlink (LINK)";
              if (s=="MATIC") return "Polygon (MATIC)";
              if (s=="POL") return "Polygon (POL)";
              if (s=="TON") return "Toncoin (TON)";
              if (s=="TRX") return "TRON (TRX)";
              if (s=="NEAR") return "NEAR (NEAR)";
              if (s=="ATOM") return "Cosmos (ATOM)";
              if (s=="APT") return "Aptos (APT)";
              if (s=="OP") return "Optimism (OP)";
              if (s=="ARB") return "Arbitrum (ARB)";
              if (s=="SUI") return "Sui (SUI)";
              return s + " (" + s + ")";
            };
            lv_label_set_text(id(coin_title), pretty(id(sel_row5).state).c_str());
            lv_label_set_text(id(coin_price_line), lv_label_get_text(id(bnb_val)));
        - lvgl.widget.hide: page_prices
        - lvgl.widget.show: page_coin
        - script.execute: fetch_prices

  # ---- Alert bar: tap to dismiss ----
  - platform: lvgl
    id: bs_alert_dismiss
    widget: btn_alert_dismiss
    on_click:
      then:
        - lvgl.widget.hide: alert_bar
        - lambda: |-
            id(status_line).publish_state("Alert dismissed");

# Manual refresh button in HA
button:
  - platform: template
    name: "Refresh prices"
    id: refresh_now
    on_press:
      - lvgl.label.update: { id: status, text: "Fetching (manual)..." }
      - script.execute: fetch_prices

# ===== Fiat + Coin selectors (Home Assistant) =====
select:
  - platform: template
    name: "Fiat Currency"
    id: sel_currency
    optimistic: true
    options: ["DKK","EUR","USD","SEK","NOK","GBP"]
    initial_option: "DKK"
    restore_value: yes
    on_value:
      - lambda: |-
          id(prev_usd_rate) = id(usd2dkk);
          id(pending_fx_conv) = true;
      - lambda: |-
          if (lv_obj_is_valid(id(lbl_currency))) lv_label_set_text(id(lbl_currency), x.c_str());
          if (lv_obj_is_valid(id(title))) {
            char ttl[32]; snprintf(ttl, sizeof(ttl), "Crypto (%s)", x.c_str());
            lv_label_set_text(id(title), ttl);
          }
      - script.execute: fetch_prices

  - platform: template
    name: "Row 1 Coin"
    id: sel_row1
    optimistic: true
    options: ["BTC","ETH","SOL","ADA","BNB","XRP","DOGE","AVAX","DOT","LINK","MATIC","POL","TON","TRX","NEAR","ATOM","APT","OP","ARB","SUI"]
    initial_option: "BTC"
    restore_value: yes
    on_value:
      - lambda: |-
          auto pretty = [](const std::string& s)->std::string{
            if (s=="BTC") return "Bitcoin (BTC)";
            if (s=="ETH") return "Ethereum (ETH)";
            if (s=="SOL") return "Solana (SOL)";
            if (s=="ADA") return "Cardano (ADA)";
            if (s=="BNB") return "BNB (BNB)";
            if (s=="XRP") return "XRP (XRP)";
            if (s=="DOGE") return "Dogecoin (DOGE)";
            if (s=="AVAX") return "Avalanche (AVAX)";
            if (s=="DOT") return "Polkadot (DOT)";
            if (s=="LINK") return "Chainlink (LINK)";
            if (s=="MATIC") return "Polygon (MATIC)";
            if (s=="POL") return "Polygon (POL)";
            if (s=="TON") return "Toncoin (TON)";
            if (s=="TRX") return "TRON (TRX)";
            if (s=="NEAR") return "NEAR (NEAR)";
            if (s=="ATOM") return "Cosmos (ATOM)";
            if (s=="APT") return "Aptos (APT)";
            if (s=="OP") return "Optimism (OP)";
            if (s=="ARB") return "Arbitrum (ARB)";
            if (s=="SUI") return "Sui (SUI)";
            return s + " (" + s + ")";
          };
          lv_label_set_text(id(btc_name), pretty(x).c_str());
      - script.execute: fetch_prices

  - platform: template
    name: "Row 2 Coin"
    id: sel_row2
    optimistic: true
    options: ["BTC","ETH","SOL","ADA","BNB","XRP","DOGE","AVAX","DOT","LINK","MATIC","POL","TON","TRX","NEAR","ATOM","APT","OP","ARB","SUI"]
    initial_option: "ETH"
    restore_value: yes
    on_value:
      - lambda: |-
          auto pretty = [](const std::string& s)->std::string{
            if (s=="BTC") return "Bitcoin (BTC)";
            if (s=="ETH") return "Ethereum (ETH)";
            if (s=="SOL") return "Solana (SOL)";
            if (s=="ADA") return "Cardano (ADA)";
            if (s=="BNB") return "BNB (BNB)";
            if (s=="XRP") return "XRP (XRP)";
            if (s=="DOGE") return "Dogecoin (DOGE)";
            if (s=="AVAX") return "Avalanche (AVAX)";
            if (s=="DOT") return "Polkadot (DOT)";
            if (s=="LINK") return "Chainlink (LINK)";
            if (s=="MATIC") return "Polygon (MATIC)";
            if (s=="POL") return "Polygon (POL)";
            if (s=="TON") return "Toncoin (TON)";
            if (s=="TRX") return "TRON (TRX)";
            if (s=="NEAR") return "NEAR (NEAR)";
            if (s=="ATOM") return "Cosmos (ATOM)";
            if (s=="APT") return "Aptos (APT)";
            if (s=="OP") return "Optimism (OP)";
            if (s=="ARB") return "Arbitrum (ARB)";
            if (s=="SUI") return "Sui (SUI)";
            return s + " (" + s + ")";
          };
          lv_label_set_text(id(eth_name), pretty(x).c_str());
      - script.execute: fetch_prices

  - platform: template
    name: "Row 3 Coin"
    id: sel_row3
    optimistic: true
    options: ["BTC","ETH","SOL","ADA","BNB","XRP","DOGE","AVAX","DOT","LINK","MATIC","POL","TON","TRX","NEAR","ATOM","APT","OP","ARB","SUI"]
    initial_option: "SOL"
    restore_value: yes
    on_value:
      - lambda: |-
          auto pretty = [](const std::string& s)->std::string{
            if (s=="BTC") return "Bitcoin (BTC)";
            if (s=="ETH") return "Ethereum (ETH)";
            if (s=="SOL") return "Solana (SOL)";
            if (s=="ADA") return "Cardano (ADA)";
            if (s=="BNB") return "BNB (BNB)";
            if (s=="XRP") return "XRP (XRP)";
            if (s=="DOGE") return "Dogecoin (DOGE)";
            if (s=="AVAX") return "Avalanche (AVAX)";
            if (s=="DOT") return "Polkadot (DOT)";
            if (s=="LINK") return "Chainlink (LINK)";
            if (s=="MATIC") return "Polygon (MATIC)";
            if (s=="POL") return "Polygon (POL)";
            if (s=="TON") return "Toncoin (TON)";
            if (s=="TRX") return "TRON (TRX)";
            if (s=="NEAR") return "NEAR (NEAR)";
            if (s=="ATOM") return "Cosmos (ATOM)";
            if (s=="APT") return "Aptos (APT)";
            if (s=="OP") return "Optimism (OP)";
            if (s=="ARB") return "Arbitrum (ARB)";
            if (s=="SUI") return "Sui (SUI)";
            return s + " (" + s + ")";
          };
          lv_label_set_text(id(sol_name), pretty(x).c_str());
      - script.execute: fetch_prices

  - platform: template
    name: "Row 4 Coin"
    id: sel_row4
    optimistic: true
    options: ["BTC","ETH","SOL","ADA","BNB","XRP","DOGE","AVAX","DOT","LINK","MATIC","POL","TON","TRX","NEAR","ATOM","APT","OP","ARB","SUI"]
    initial_option: "ADA"
    restore_value: yes
    on_value:
      - lambda: |-
          auto pretty = [](const std::string& s)->std::string{
            if (s=="BTC") return "Bitcoin (BTC)";
            if (s=="ETH") return "Ethereum (ETH)";
            if (s=="SOL") return "Solana (SOL)";
            if (s=="ADA") return "Cardano (ADA)";
            if (s=="BNB") return "BNB (BNB)";
            if (s=="XRP") return "XRP (XRP)";
            if (s=="DOGE") return "Dogecoin (DOGE)";
            if (s=="AVAX") return "Avalanche (AVAX)";
            if (s=="DOT") return "Polkadot (DOT)";
            if (s=="LINK") return "Chainlink (LINK)";
            if (s=="MATIC") return "Polygon (MATIC)";
            if (s=="POL") return "Polygon (POL)";
            if (s=="TON") return "Toncoin (TON)";
            if (s=="TRX") return "TRON (TRX)";
            if (s=="NEAR") return "NEAR (NEAR)";
            if (s=="ATOM") return "Cosmos (ATOM)";
            if (s=="APT") return "Aptos (APT)";
            if (s=="OP") return "Optimism (OP)";
            if (s=="ARB") return "Arbitrum (ARB)";
            if (s=="SUI") return "Sui (SUI)";
            return s + " (" + s + ")";
          };
          lv_label_set_text(id(ada_name), pretty(x).c_str());
      - script.execute: fetch_prices

  - platform: template
    name: "Row 5 Coin"
    id: sel_row5
    optimistic: true
    options: ["BTC","ETH","SOL","ADA","BNB","XRP","DOGE","AVAX","DOT","LINK","MATIC","POL","TON","TRX","NEAR","ATOM","APT","OP","ARB","SUI"]
    initial_option: "BNB"
    restore_value: yes
    on_value:
      - lambda: |-
          auto pretty = [](const std::string& s)->std::string{
            if (s=="BTC") return "Bitcoin (BTC)";
            if (s=="ETH") return "Ethereum (ETH)";
            if (s=="SOL") return "Solana (SOL)";
            if (s=="ADA") return "Cardano (ADA)";
            if (s=="BNB") return "BNB (BNB)";
            if (s=="XRP") return "XRP (XRP)";
            if (s=="DOGE") return "Dogecoin (DOGE)";
            if (s=="AVAX") return "Avalanche (AVAX)";
            if (s=="DOT") return "Polkadot (DOT)";
            if (s=="LINK") return "Chainlink (LINK)";
            if (s=="MATIC") return "Polygon (MATIC)";
            if (s=="POL") return "Polygon (POL)";
            if (s=="TON") return "Toncoin (TON)";
            if (s=="TRX") return "TRON (TRX)";
            if (s=="NEAR") return "NEAR (NEAR)";
            if (s=="ATOM") return "Cosmos (ATOM)";
            if (s=="APT") return "Aptos (APT)";
            if (s=="OP") return "Optimism (OP)";
            if (s=="ARB") return "Arbitrum (ARB)";
            if (s=="SUI") return "Sui (SUI)";
            return s + " (" + s + ")";
          };
          lv_label_set_text(id(bnb_name), pretty(x).c_str());
      - script.execute: fetch_prices

# NEW: Alert controls in Home Assistant (threshold number + toggles)
number:
  - platform: template
    name: "Alert Threshold Row 1"
    id: num_alert_btc
    min_value: 0
    max_value: 1000000
    step: 0.01
    restore_value: yes
    initial_value: 0
    entity_category: config 
    set_action:
      - lambda: |-
          id(alert_price_btc) = x;

  - platform: template
    name: "Alert Threshold Row 2"
    id: num_alert_eth
    min_value: 0
    max_value: 1000000
    step: 0.01
    restore_value: yes
    initial_value: 0
    entity_category: config 
    set_action:
      - lambda: |-
          id(alert_price_eth) = x;

  - platform: template
    name: "Alert Threshold Row 3"
    id: num_alert_sol
    min_value: 0
    max_value: 1000000
    step: 0.01
    restore_value: yes
    initial_value: 0
    entity_category: config
    set_action:
      - lambda: |-
          id(alert_price_sol) = x;

  - platform: template
    name: "Alert Threshold Row 4"
    id: num_alert_ada
    min_value: 0
    max_value: 1000000
    step: 0.01
    restore_value: yes
    initial_value: 0
    entity_category: config
    set_action:
      - lambda: |-
          id(alert_price_ada) = x;

  - platform: template
    name: "Alert Threshold Row 5"
    id: num_alert_bnb
    min_value: 0
    max_value: 1000000
    step: 0.01
    restore_value: yes
    initial_value: 0
    entity_category: config
    set_action:
      - lambda: |-
          id(alert_price_bnb) = x;

switch:
  # Enabled toggles
  - platform: template
    name: "Alert Enabled Row 1"
    id: sw_alert_enabled_btc
    entity_category: config 
    lambda: |-
      return id(alert_enabled_btc);
    turn_on_action:
      - lambda: |-
          id(alert_enabled_btc) = true;
    turn_off_action:
      - lambda: |-
          id(alert_enabled_btc) = false;

  - platform: template
    name: "Alert Enabled Row 2"
    id: sw_alert_enabled_eth
    entity_category: config 
    lambda: |-
      return id(alert_enabled_eth);
    turn_on_action:
      - lambda: |-
          id(alert_enabled_eth) = true;
    turn_off_action:
      - lambda: |-
          id(alert_enabled_eth) = false;

  - platform: template
    name: "Alert Enabled Row 3"
    id: sw_alert_enabled_sol
    entity_category: config
    lambda: |-
      return id(alert_enabled_sol);
    turn_on_action:
      - lambda: |-
          id(alert_enabled_sol) = true;
    turn_off_action:
      - lambda: |-
          id(alert_enabled_sol) = false;

  - platform: template
    name: "Alert Enabled Row 4"
    id: sw_alert_enabled_ada
    entity_category: config
    lambda: |-
      return id(alert_enabled_ada);
    turn_on_action:
      - lambda: |-
          id(alert_enabled_ada) = true;
    turn_off_action:
      - lambda: |-
          id(alert_enabled_ada) = false;

  - platform: template
    name: "Alert Enabled Row 5"
    id: sw_alert_enabled_bnb
    entity_category: config
    lambda: |-
      return id(alert_enabled_bnb);
    turn_on_action:
      - lambda: |-
          id(alert_enabled_bnb) = true;
    turn_off_action:
      - lambda: |-
          id(alert_enabled_bnb) = false;

  # Direction toggles (ON = Above (≥), OFF = Below (≤))
  - platform: template
    name: "Alert Above Row 1 (off = Below)"
    id: sw_alert_dir_btc
    entity_category: config
    lambda: |-
      return id(alert_dir_btc) >= 0;
    turn_on_action:
      - lambda: |-
          id(alert_dir_btc) = 1;
    turn_off_action:
      - lambda: |-
          id(alert_dir_btc) = -1;

  - platform: template
    name: "Alert Above Row 2 (off = Below)"
    id: sw_alert_dir_eth
    entity_category: config
    lambda: |-
      return id(alert_dir_eth) >= 0;
    turn_on_action:
      - lambda: |-
          id(alert_dir_eth) = 1;
    turn_off_action:
      - lambda: |-
          id(alert_dir_eth) = -1;

  - platform: template
    name: "Alert Above Row 3 (off = Below)"
    id: sw_alert_dir_sol
    entity_category: config
    lambda: |-
      return id(alert_dir_sol) >= 0;
    turn_on_action:
      - lambda: |-
          id(alert_dir_sol) = 1;
    turn_off_action:
      - lambda: |-
          id(alert_dir_sol) = -1;

  - platform: template
    name: "Alert Above Row 4 (off = Below)"
    id: sw_alert_dir_ada
    entity_category: config
    lambda: |-
      return id(alert_dir_ada) >= 0;
    turn_on_action:
      - lambda: |-
          id(alert_dir_ada) = 1;
    turn_off_action:
      - lambda: |-
          id(alert_dir_ada) = -1;

  - platform: template
    name: "Alert Above Row 5 (off = Below)"
    id: sw_alert_dir_bnb
    entity_category: config
    lambda: |-
      return id(alert_dir_bnb) >= 0;
    turn_on_action:
      - lambda: |-
          id(alert_dir_bnb) = 1;
    turn_off_action:
      - lambda: |-
          id(alert_dir_bnb) = -1;

# HTTP client
http_request:
  verify_ssl: false
  timeout: 7000ms

# USD->[selected] rate + toggles + alert state
globals:
  - id: usd2dkk
    type: float
    restore_value: no
    initial_value: '7.0'

  - id: colorize_pct
    type: bool
    restore_value: yes
    initial_value: 'true'

  # Which coin is shown on detail page: 0..4 for rows 1..5
  - id: current_coin
    type: int
    restore_value: no
    initial_value: '0'

  # Per-row alert enabled + fired
  - id: alert_enabled_btc
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: alert_fired_btc
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: alert_enabled_eth
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: alert_fired_eth
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: alert_enabled_sol
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: alert_fired_sol
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: alert_enabled_ada
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: alert_fired_ada
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: alert_enabled_bnb
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: alert_fired_bnb
    type: bool
    restore_value: no
    initial_value: 'false'

  # -------- Price-based alert thresholds (in selected fiat) + direction (+1 ≥, -1 ≤)
  - id: alert_price_btc
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: alert_dir_btc
    type: int
    restore_value: yes
    initial_value: '1'

  - id: alert_price_eth
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: alert_dir_eth
    type: int
    restore_value: yes
    initial_value: '1'

  - id: alert_price_sol
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: alert_dir_sol
    type: int
    restore_value: yes
    initial_value: '1'

  - id: alert_price_ada
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: alert_dir_ada
    type: int
    restore_value: yes
    initial_value: '1'

  - id: alert_price_bnb
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: alert_dir_bnb
    type: int
    restore_value: yes
    initial_value: '1'

  # Track last converted fiat price for step sizing
  - id: last_fiat_btc
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: last_fiat_eth
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: last_fiat_sol
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: last_fiat_ada
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: last_fiat_bnb
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: prev_usd_rate
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: pending_fx_conv
    type: bool
    restore_value: no
    initial_value: 'false'

# ====================== Data Fetch ======================
script:
  # Flash the alert bar a few times
  - id: alert_flash
    then:
      - lvgl.widget.show: alert_bar
      - repeat:
          count: 6
          then:
            - lvgl.widget.hide: alert_bar
            - delay: 200ms
            - lvgl.widget.show: alert_bar
            - delay: 200ms

  # 1) Get USD->[selected currency] via Frankfurter
  - id: fetch_prices
    mode: queued
    then:
      - lvgl.label.update: { id: status, text: "FX..." }
      - http_request.get:
          url: !lambda |-
            std::string cur = id(sel_currency).state;
            char buf[128];
            snprintf(buf, sizeof(buf),
                     "https://api.frankfurter.app/latest?from=USD&to=%s",
                     cur.c_str());
            return std::string(buf);
          request_headers: { Accept: application/json }
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGD("crypto", "FX body: %s", body.c_str());
                  bool ok = false;
                  std::string cur = id(sel_currency).state;

                  StaticJsonDocument<512> doc;
                  DeserializationError e = deserializeJson(doc, body);
                  if (!e && doc["rates"][cur.c_str()]) {
                    id(usd2dkk) = doc["rates"][cur.c_str()].as<float>();  // USD->[cur]
                    ok = true;
                  }

                  // --- Auto-convert saved thresholds if fiat changed successfully ---
                  if (ok && id(pending_fx_conv)) {
                    float oldr = id(prev_usd_rate);
                    float newr = id(usd2dkk);
                    if (oldr > 0.0f && fabsf(newr - oldr) > 1e-6f) {
                      float k = newr / oldr;

                      id(alert_price_btc) *= k;
                      id(alert_price_eth) *= k;
                      id(alert_price_sol) *= k;
                      id(alert_price_ada) *= k;
                      id(alert_price_bnb) *= k;

                      // Sync HA number entities with the converted thresholds
                      id(num_alert_btc).publish_state(id(alert_price_btc));
                      id(num_alert_eth).publish_state(id(alert_price_eth));
                      id(num_alert_sol).publish_state(id(alert_price_sol));
                      id(num_alert_ada).publish_state(id(alert_price_ada));
                      id(num_alert_bnb).publish_state(id(alert_price_bnb));
                    }
                    id(pending_fx_conv) = false;
                  }

                  if (ok) {
                    char fx[64];
                    snprintf(fx, sizeof(fx), "USD->%s: %.4f", cur.c_str(), id(usd2dkk));
                    id(info_fx_line).publish_state(fx);
                  } else {
                    id(info_fx_line).publish_state("USD->?: —");
                  }
                  char ttl[32]; snprintf(ttl, sizeof(ttl), "Crypto (%s)", cur.c_str());
                  lv_label_set_text(id(title), ttl);

                  ESP_LOGD("crypto", "USD->%s = %.4f", cur.c_str(), id(usd2dkk));
                  id(status_line).publish_state(ok ? "FX OK" : "FX parse error");
              - script.execute: fetch_coins
          on_error:
            then:
              - lambda: |-
                  id(status_line).publish_state("FX HTTP error (using cached FX)");
                  std::string cur = id(sel_currency).state;
                  char fx[64];
                  snprintf(fx, sizeof(fx), "USD->%s: %.4f", cur.c_str(), id(usd2dkk));
                  id(info_fx_line).publish_state(fx);
              - script.execute: fetch_coins

  # 2) Per-row requests from Binance + colorize + alerts + LVGL line chart
  - id: fetch_coins
    then:
      - lvgl.label.update: { id: status, text: "Prices..." }

      # Row 1
      - http_request.get:
          url: !lambda |-
            std::string sym = id(sel_row1).state;
            std::string pair = sym + "USDT";
            return "https://api.binance.com/api/v3/ticker/24hr?symbol=" + pair;
          request_headers: { Accept: application/json }
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  StaticJsonDocument<1024> doc;
                  DeserializationError err = deserializeJson(doc, body);
                  if (!err) {
                    const char* lp = doc["lastPrice"] | "0";
                    const char* pc = doc["priceChangePercent"] | "0";
                    double price = atof(lp);
                    double pct   = atof(pc);
                    double fiat  = price * id(usd2dkk);

                    std::string cur = id(sel_currency).state;

                    // Save last fiat for step sizing
                    id(last_fiat_btc) = fiat;

                    char out[96];
                    if (id(colorize_pct)) {
                      const char* col = (pct > 0.005) ? "#10B981" : (pct < -0.005) ? "#EF4444" : "#94A3B8";
                      snprintf(out, sizeof(out), "%s %.2f  (%s %+.2f%%#)", cur.c_str(), fiat, col, pct);
                    } else {
                      snprintf(out, sizeof(out), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                    }
                    id(btc_line).publish_state(out);

                    // HA-friendly copy (no recolor tags)
                    {
                      char out_ha[96];
                      snprintf(out_ha, sizeof(out_ha), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                      id(btc_line_ha).publish_state(out_ha);
                    }

                    // Alerts (price-based)
                    {
                      float thr   = id(alert_price_btc);
                      int   dir   = id(alert_dir_btc);   // +1 => ≥, -1 => ≤
                      bool  en    = id(alert_enabled_btc);
                      bool &fired = id(alert_fired_btc);
                      if (en && thr > 0.0f) {
                        bool hit = (dir >= 0) ? (fiat >= thr) : (fiat <= thr);
                        if (!fired && hit) {
                          fired = true;
                          const char* op = (dir >= 0) ? "≥" : "≤";
                          char s[96];
                          snprintf(s, sizeof(s), "ALERT: %s %s %.2f (now %s %.2f)", id(sel_row1).state.c_str(), op, thr, cur.c_str(), fiat);
                          id(status_line).publish_state(s);
                          lv_label_set_text(id(alert_text), s);
                          id(alert_flash).execute();
                        } else if (fired) {
                          // 0.5% hysteresis around threshold
                          float up = thr * 1.005f;
                          float dn = thr * 0.995f;
                          if ( (dir >= 0 && fiat < dn) || (dir < 0 && fiat > up) ) fired = false;
                        }
                      } else {
                        fired = false;
                      }
                    }

                    // ---- Row 1 line chart (40 samples) ----
                    static float hist1[40]; static int len1=0, idx1=0;
                    {
                      const int cap = 40;
                      if (len1 < cap) hist1[len1++] = fiat;
                      else { hist1[idx1] = fiat; idx1 = (idx1 + 1) % cap; }

                      if (id(current_coin) == 0) {
                        const int w = 736, h = 176;
                        const int n = len1;
                        if (n >= 2) {
                          const int start = (n < cap) ? 0 : idx1;
                          float mn = hist1[start], mx = mn;
                          for (int k=1;k<n;k++){ float v=hist1[(start+k)%cap]; if(v<mn) mn=v; if(v>mx) mx=v; }
                          if (mx - mn < 1e-6f) mx = mn + 1.0f;
                          static lv_point_t pts[40];
                          for (int k=0;k<n;k++){
                            float v=hist1[(start+k)%cap];
                            float t=(v-mn)/(mx-mn);
                            int x=(int)((float)k*(w-1)/(n-1)+0.5f);
                            int y=(int)((1.0f-t)*(h-1)+0.5f);
                            pts[k].x=x; pts[k].y=y;
                          }
                          lv_obj_set_size(id(chart_line)->obj, w, h);
                          lv_line_set_points(id(chart_line)->obj, pts, n);
                        }
                      }
                    }
                  } else {
                    id(status_line).publish_state("Row1 parse error");
                  }
          on_error:
            then:
              - lambda: id(status_line).publish_state("Row1 HTTP error");

      # Row 2
      - http_request.get:
          url: !lambda |-
            std::string sym = id(sel_row2).state;
            std::string pair = sym + "USDT";
            return "https://api.binance.com/api/v3/ticker/24hr?symbol=" + pair;
          request_headers: { Accept: application/json }
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  StaticJsonDocument<1024> doc;
                  DeserializationError err = deserializeJson(doc, body);
                  if (!err) {
                    const char* lp = doc["lastPrice"] | "0";
                    const char* pc = doc["priceChangePercent"] | "0";
                    double price = atof(lp);
                    double pct   = atof(pc);
                    double fiat  = price * id(usd2dkk);

                    std::string cur = id(sel_currency).state;

                    id(last_fiat_eth) = fiat;

                    char out[96];
                    if (id(colorize_pct)) {
                      const char* col = (pct > 0.005) ? "#10B981" : (pct < -0.005) ? "#EF4444" : "#94A3B8";
                      snprintf(out, sizeof(out), "%s %.2f  (%s %+.2f%%#)", cur.c_str(), fiat, col, pct);
                    } else {
                      snprintf(out, sizeof(out), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                    }
                    id(eth_line).publish_state(out);

                    // HA-friendly copy
                    {
                      char out_ha[96];
                      snprintf(out_ha, sizeof(out_ha), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                      id(eth_line_ha).publish_state(out_ha);
                    }

                    // Alerts (price-based)
                    {
                      float thr   = id(alert_price_eth);
                      int   dir   = id(alert_dir_eth);
                      bool  en    = id(alert_enabled_eth);
                      bool &fired = id(alert_fired_eth);
                      if (en && thr > 0.0f) {
                        bool hit = (dir >= 0) ? (fiat >= thr) : (fiat <= thr);
                        if (!fired && hit) {
                          fired = true;
                          const char* op = (dir >= 0) ? "≥" : "≤";
                          char s[96];
                          snprintf(s, sizeof(s), "ALERT: %s %s %.2f (now %s %.2f)", id(sel_row2).state.c_str(), op, thr, cur.c_str(), fiat);
                          id(status_line).publish_state(s);
                          lv_label_set_text(id(alert_text), s);
                          id(alert_flash).execute();
                        } else if (fired) {
                          float up = thr * 1.005f;
                          float dn = thr * 0.995f;
                          if ( (dir >= 0 && fiat < dn) || (dir < 0 && fiat > up) ) fired = false;
                        }
                      } else {
                        fired = false;
                      }
                    }

                    static float hist2[40]; static int len2=0, idx2=0;
                    {
                      const int cap=40;
                      if (len2 < cap) hist2[len2++] = fiat;
                      else { hist2[idx2] = fiat; idx2 = (idx2 + 1) % cap; }

                      if (id(current_coin) == 1) {
                        const int w=736, h=176, n=len2;
                        if (n >= 2) {
                          const int start=(n<cap)?0:idx2;
                          float mn=hist2[start], mx=mn;
                          for (int k=1;k<n;k++){ float v=hist2[(start+k)%cap]; if(v<mn) mn=v; if(v>mx) mx=v; }
                          if (mx-mn<1e-6f) mx = mn + 1.0f;
                          static lv_point_t pts[40];
                          for (int k=0;k<n;k++){
                            float v=hist2[(start+k)%cap], t=(v-mn)/(mx-mn);
                            int x=(int)((float)k*(w-1)/(n-1)+0.5f);
                            int y=(int)((1.0f-t)*(h-1)+0.5f);
                            pts[k].x=x; pts[k].y=y;
                          }
                          lv_obj_set_size(id(chart_line)->obj, w, h);
                          lv_line_set_points(id(chart_line)->obj, pts, n);
                        }
                      }
                    }
                  } else {
                    id(status_line).publish_state("Row2 parse error");
                  }
          on_error:
            then:
              - lambda: id(status_line).publish_state("Row2 HTTP error");

      # Row 3
      - http_request.get:
          url: !lambda |-
            std::string sym = id(sel_row3).state;
            std::string pair = sym + "USDT";
            return "https://api.binance.com/api/v3/ticker/24hr?symbol=" + pair;
          request_headers: { Accept: application/json }
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  StaticJsonDocument<1024> doc;
                  DeserializationError err = deserializeJson(doc, body);
                  if (!err) {
                    const char* lp = doc["lastPrice"] | "0";
                    const char* pc = doc["priceChangePercent"] | "0";
                    double price = atof(lp);
                    double pct   = atof(pc);
                    double fiat  = price * id(usd2dkk);

                    std::string cur = id(sel_currency).state;

                    id(last_fiat_sol) = fiat;

                    char out[96];
                    if (id(colorize_pct)) {
                      const char* col = (pct > 0.005) ? "#10B981" : (pct < -0.005) ? "#EF4444" : "#94A3B8";
                      snprintf(out, sizeof(out), "%s %.2f  (%s %+.2f%%#)", cur.c_str(), fiat, col, pct);
                    } else {
                      snprintf(out, sizeof(out), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                    }
                    id(sol_line).publish_state(out);

                    // HA-friendly copy
                    {
                      char out_ha[96];
                      snprintf(out_ha, sizeof(out_ha), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                      id(sol_line_ha).publish_state(out_ha);
                    }

                    // Alerts (price-based)
                    {
                      float thr   = id(alert_price_sol);
                      int   dir   = id(alert_dir_sol);
                      bool  en    = id(alert_enabled_sol);
                      bool &fired = id(alert_fired_sol);
                      if (en && thr > 0.0f) {
                        bool hit = (dir >= 0) ? (fiat >= thr) : (fiat <= thr);
                        if (!fired && hit) {
                          fired = true;
                          const char* op = (dir >= 0) ? "≥" : "≤";
                          char s[96];
                          snprintf(s, sizeof(s), "ALERT: %s %s %.2f (now %s %.2f)", id(sel_row3).state.c_str(), op, thr, cur.c_str(), fiat);
                          id(status_line).publish_state(s);
                          lv_label_set_text(id(alert_text), s);
                          id(alert_flash).execute();
                        } else if (fired) {
                          float up = thr * 1.005f;
                          float dn = thr * 0.995f;
                          if ( (dir >= 0 && fiat < dn) || (dir < 0 && fiat > up) ) fired = false;
                        }
                      } else {
                        fired = false;
                      }
                    }

                    static float hist3[40]; static int len3=0, idx3=0;
                    {
                      const int cap=40;
                      if (len3 < cap) hist3[len3++] = fiat;
                      else { hist3[idx3] = fiat; idx3 = (idx3 + 1) % cap; }

                      if (id(current_coin) == 2) {
                        const int w=736, h=176, n=len3;
                        if (n >= 2) {
                          const int start=(n<cap)?0:idx3;
                          float mn=hist3[start], mx=mn;
                          for (int k=1;k<n;k++){ float v=hist3[(start+k)%cap]; if(v<mn) mn=v; if(v>mx) mx=v; }
                          if (mx-mn<1e-6f) mx = mn + 1.0f;
                          static lv_point_t pts[40];
                          for (int k=0;k<n;k++){
                            float v=hist3[(start+k)%cap], t=(v-mn)/(mx-mn);
                            int x=(int)((float)k*(w-1)/(n-1)+0.5f);
                            int y=(int)((1.0f-t)*(h-1)+0.5f);
                            pts[k].x=x; pts[k].y=y;
                          }
                          lv_obj_set_size(id(chart_line)->obj, w, h);
                          lv_line_set_points(id(chart_line)->obj, pts, n);
                        }
                      }
                    }
                  } else {
                    id(status_line).publish_state("Row3 parse error");
                  }
          on_error:
            then:
              - lambda: id(status_line).publish_state("Row3 HTTP error");

      # Row 4
      - http_request.get:
          url: !lambda |-
            std::string sym = id(sel_row4).state;
            std::string pair = sym + "USDT";
            return "https://api.binance.com/api/v3/ticker/24hr?symbol=" + pair;
          request_headers: { Accept: application/json }
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  StaticJsonDocument<1024> doc;
                  DeserializationError err = deserializeJson(doc, body);
                  if (!err) {
                    const char* lp = doc["lastPrice"] | "0";
                    const char* pc = doc["priceChangePercent"] | "0";
                    double price = atof(lp);
                    double pct   = atof(pc);
                    double fiat  = price * id(usd2dkk);

                    std::string cur = id(sel_currency).state;

                    id(last_fiat_ada) = fiat;

                    char out[96];
                    if (id(colorize_pct)) {
                      const char* col = (pct > 0.005) ? "#10B981" : (pct < -0.005) ? "#EF4444" : "#94A3B8";
                      snprintf(out, sizeof(out), "%s %.2f  (%s %+.2f%%#)", cur.c_str(), fiat, col, pct);
                    } else {
                      snprintf(out, sizeof(out), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                    }
                    id(ada_line).publish_state(out);

                    // HA-friendly copy
                    {
                      char out_ha[96];
                      snprintf(out_ha, sizeof(out_ha), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                      id(ada_line_ha).publish_state(out_ha);
                    }

                    // Alerts (price-based)
                    {
                      float thr   = id(alert_price_ada);
                      int   dir   = id(alert_dir_ada);
                      bool  en    = id(alert_enabled_ada);
                      bool &fired = id(alert_fired_ada);
                      if (en && thr > 0.0f) {
                        bool hit = (dir >= 0) ? (fiat >= thr) : (fiat <= thr);
                        if (!fired && hit) {
                          fired = true;
                          const char* op = (dir >= 0) ? "≥" : "≤";
                          char s[96];
                          snprintf(s, sizeof(s), "ALERT: %s %s %.2f (now %s %.2f)", id(sel_row4).state.c_str(), op, thr, cur.c_str(), fiat);
                          id(status_line).publish_state(s);
                          lv_label_set_text(id(alert_text), s);
                          id(alert_flash).execute();
                        } else if (fired) {
                          float up = thr * 1.005f;
                          float dn = thr * 0.995f;
                          if ( (dir >= 0 && fiat < dn) || (dir < 0 && fiat > up) ) fired = false;
                        }
                      } else {
                        fired = false;
                      }
                    }

                    static float hist4[40]; static int len4=0, idx4=0;
                    {
                      const int cap=40;
                      if (len4 < cap) hist4[len4++] = fiat;
                      else { hist4[idx4] = fiat; idx4 = (idx4 + 1) % cap; }

                      if (id(current_coin) == 3) {
                        const int w=736, h=176, n=len4;
                        if (n >= 2) {
                          const int start=(n<cap)?0:idx4;
                          float mn=hist4[start], mx=mn;
                          for (int k=1;k<n;k++){ float v=hist4[(start+k)%cap]; if(v<mn) mn=v; if(v>mx) mx=v; }
                          if (mx-mn<1e-6f) mx = mn + 1.0f;
                          static lv_point_t pts[40];
                          for (int k=0;k<n;k++){
                            float v=hist4[(start+k)%cap], t=(v-mn)/(mx-mn);
                            int x=(int)((float)k*(w-1)/(n-1)+0.5f);
                            int y=(int)((1.0f-t)*(h-1)+0.5f);
                            pts[k].x=x; pts[k].y=y;
                          }
                          lv_obj_set_size(id(chart_line)->obj, w, h);
                          lv_line_set_points(id(chart_line)->obj, pts, n);
                        }
                      }
                    }
                  } else {
                    id(status_line).publish_state("Row4 parse error");
                  }
          on_error:
            then:
              - lambda: id(status_line).publish_state("Row4 HTTP error");

      # Row 5
      - http_request.get:
          url: !lambda |-
            std::string sym = id(sel_row5).state;
            std::string pair = sym + "USDT";
            return "https://api.binance.com/api/v3/ticker/24hr?symbol=" + pair;
          request_headers: { Accept: application/json }
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  StaticJsonDocument<1024> doc;
                  DeserializationError err = deserializeJson(doc, body);
                  if (!err) {
                    const char* lp = doc["lastPrice"] | "0";
                    const char* pc = doc["priceChangePercent"] | "0";
                    double price = atof(lp);
                    double pct   = atof(pc);
                    double fiat  = price * id(usd2dkk);

                    std::string cur = id(sel_currency).state;

                    id(last_fiat_bnb) = fiat;

                    char out[96];
                    if (id(colorize_pct)) {
                      const char* col = (pct > 0.005) ? "#10B981" : (pct < -0.005) ? "#EF4444" : "#94A3B8";
                      snprintf(out, sizeof(out), "%s %.2f  (%s %+.2f%%#)", cur.c_str(), fiat, col, pct);
                    } else {
                      snprintf(out, sizeof(out), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                    }
                    id(bnb_line).publish_state(out);

                    // HA-friendly copy
                    {
                      char out_ha[96];
                      snprintf(out_ha, sizeof(out_ha), "%s %.2f  (%+.2f%%)", cur.c_str(), fiat, pct);
                      id(bnb_line_ha).publish_state(out_ha);
                    }

                    // Alerts (price-based)
                    {
                      float thr   = id(alert_price_bnb);
                      int   dir   = id(alert_dir_bnb);
                      bool  en    = id(alert_enabled_bnb);
                      bool &fired = id(alert_fired_bnb);
                      if (en && thr > 0.0f) {
                        bool hit = (dir >= 0) ? (fiat >= thr) : (fiat <= thr);
                        if (!fired && hit) {
                          fired = true;
                          const char* op = (dir >= 0) ? "≥" : "≤";
                          char s[96];
                          snprintf(s, sizeof(s), "ALERT: %s %s %.2f (now %s %.2f)", id(sel_row5).state.c_str(), op, thr, cur.c_str(), fiat);
                          id(status_line).publish_state(s);
                          lv_label_set_text(id(alert_text), s);
                          id(alert_flash).execute();
                        } else if (fired) {
                          float up = thr * 1.005f;
                          float dn = thr * 0.995f;
                          if ( (dir >= 0 && fiat < dn) || (dir < 0 && fiat > up) ) fired = false;
                        }
                      } else {
                        fired = false;
                      }
                    }

                    static float hist5[40]; static int len5=0, idx5=0;
                    {
                      const int cap=40;
                      if (len5 < cap) hist5[len5++] = fiat;
                      else { hist5[idx5] = fiat; idx5 = (idx5 + 1) % cap; }

                      if (id(current_coin) == 4) {
                        const int w=736, h=176, n=len5;
                        if (n >= 2) {
                          const int start=(n<cap)?0:idx5;
                          float mn=hist5[start], mx=mn;
                          for (int k=1;k<n;k++){ float v=hist5[(start+k)%cap]; if(v<mn) mn=v; if(v>mx) mx=v; }
                          if (mx-mn<1e-6f) mx = mn + 1.0f;
                          static lv_point_t pts[40];
                          for (int k=0;k<n;k++){
                            float v=hist5[(start+k)%cap], t=(v-mn)/(mx-mn);
                            int x=(int)((float)k*(w-1)/(n-1)+0.5f);
                            int y=(int)((1.0f-t)*(h-1)+0.5f);
                            pts[k].x=x; pts[k].y=y;
                          }
                          lv_obj_set_size(id(chart_line)->obj, w, h);
                          lv_line_set_points(id(chart_line)->obj, pts, n);
                        }
                      }
                    }

                    // Stamp "Last update" on Info tab
                    {
                      auto now = id(ntp).now();
                      if (now.is_valid()) {
                        char t[48];
                        snprintf(t, sizeof(t), "Last update: %02d:%02d:%02d", now.hour, now.minute, now.second);
                        id(info_last_line).publish_state(t);
                      }
                    }
                  } else {
                    id(status_line).publish_state("Row5 parse error");
                  }
          on_error:
            then:
              - lambda: |-
                  id(status_line).publish_state("Row5 HTTP error");
                  auto now = id(ntp).now();
                  if (now.is_valid()) {
                    char t[48];
                    snprintf(t, sizeof(t), "Last update: %02d:%02d:%02d", now.hour, now.minute, now.second);
                    id(info_last_line).publish_state(t);
                  }

# Refresh every 60 s — but don't pile up if a fetch is still running
interval:
  - interval: 60s
    then:
      - if:
          condition:
            not:
              script.is_running: fetch_prices
          then:
            - script.execute: fetch_prices